%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/

%% Created for Moritz at 2018-06-24 20:39:28 +0200 


%% Saved with string encoding Unicode (UTF-8) 



@inproceedings{ComAn-splc,
	Abstract = {Software Product Line (SPL) evolution affects a variety of artifact types, each containing their artifact-specific information as well as variability information. While the former information type defines the basic content of an artifact, like the general program definition in code artifacts, the latter supports the customization of these artifacts for different products of the SPL. Existing work that aims at characterizing the state and evolution of a product line identifies general SPL evolution scenarios or evaluates the (co-)evolution of variability information in different types of artifacts. However, these results are typically based on a feature perspective, which abstracts from the SPL evolution at large. We argue that an artifact-based analysis of product line evolution will complement existing work by analyzing the intensity of changes to different artifact and information types. In this report, we therefore present an approach for and the results of the extraction and analysis of changes introduced to artifact-specific and variability information in code, build and variability model artifacts. This approach has been developed for and applied to the Linux kernel. In order to broaden our analysis, we also apply the approach to the Coreboot firmware. The results reveal the intensity of changes over the evolution history of both SPLs. Further, we compare the intensity of changes across both SPLs with respect to the size of the changes as well as over time.},
	Author = {Christian Kr\"oher and Lea Gerling and Klaus Schmid},
	Booktitle = {SPLC '18: Proceedings of the 23nd International Conference on Software Product Line},
	Date-Added = {2018-06-24 17:11:50 +0000},
	Date-Modified = {2018-06-24 17:18:36 +0000},
	Title = {Identifying the Intensity of Variability Changes in Software Product Line Evolution},
	Year = {2018}}

@techreport{KangFeatureOrientedDomain1990,
	Address = {Pittsburgh, PA},
	Author = {Kyo Kang and Sholom Cohen and James Hess and William Novak and A. Peterson},
	Date-Added = {2018-06-22 15:30:21 +0000},
	Date-Modified = {2018-06-22 15:30:21 +0000},
	Institution = {Software Engineering Institute, Carnegie Mellon University},
	Number = {CMU/SEI-90-TR-021},
	Title = {Feature-Oriented Domain Analysis (FODA) Feasibility Study},
	Url = {http://resources.sei.cmu.edu/library/asset-view.cfm?AssetID=11231},
	Year = {1990},
	Bdsk-Url-1 = {http://resources.sei.cmu.edu/library/asset-view.cfm?AssetID=11231}}

@article{gazzillo-grimm,
	Author = {Gazzillo, Paul and Grimm, Robert},
	Booktitle = {ACM SIGPLAN Notices},
	Date-Added = {2018-06-19 11:29:39 +0000},
	Date-Modified = {2018-06-19 11:30:37 +0000},
	Month = {06},
	Title = {SuperC: Parsing All of C by Taming the Preprocessor},
	Volume = {47},
	Year = {2012}}

@book{Pohl:2005:SPL:1095605,
	Address = {Berlin, Heidelberg},
	Author = {Pohl, Klaus and B\"{o}ckle, G\"{u}nter and Linden, Frank J. van der},
	Date-Added = {2018-06-19 09:07:30 +0000},
	Date-Modified = {2018-06-19 09:07:30 +0000},
	Isbn = {3540243720},
	Publisher = {Springer-Verlag},
	Title = {Software Product Line Engineering: Foundations, Principles and Techniques},
	Year = {2005}}

@misc{feature-effect-analysis,
	Date-Added = {2018-06-18 15:54:41 +0000},
	Date-Modified = {2018-06-18 15:54:51 +0000},
	Howpublished = {\url{https://github.com/KernelHaven/FeatureEffectAnalysis}},
	Lastchecked = {Jun 18 2018},
	Note = {(Accessed on Jun 18 2018)},
	Title = {KernelHaven/FeatureEffectAnalysis: Analysis components for calculating presence condtions and feature effects},
	Bdsk-Url-1 = {https://github.com/KernelHaven/FeatureEffectAnalysis}}

@misc{Nadi15wheredo,
	Author = {Sarah Nadi and Thorsten Berger and Christian K{\"a}stner and Krzysztof Czarnecki and Sarah Nadi and Thorsten Berger and Christian K{\"a}stner and Krzysztof Czarnecki},
	Date-Added = {2018-06-18 15:53:53 +0000},
	Date-Modified = {2018-06-18 15:53:53 +0000},
	Title = {Where do Configuration Constraints Stem From? An Extraction Approach and an Empirical Study},
	Year = {2015}}

@inproceedings{Dietrich:2012:RAV:2362536.2362544,
	Acmid = {2362544},
	Address = {New York, NY, USA},
	Author = {Dietrich, Christian and Tartler, Reinhard and Schr\"{o}der-Preikschat, Wolfgang and Lohmann, Daniel},
	Booktitle = {Proceedings of the 16th International Software Product Line Conference - Volume 1},
	Date-Added = {2018-06-18 06:52:18 +0000},
	Date-Modified = {2018-06-18 06:52:18 +0000},
	Doi = {10.1145/2362536.2362544},
	Isbn = {978-1-4503-1094-9},
	Keywords = {Linux, VAMOS, build systems, configurability, kbuild, maintenance, static analysis},
	Location = {Salvador, Brazil},
	Numpages = {10},
	Pages = {21--30},
	Publisher = {ACM},
	Series = {SPLC '12},
	Title = {A Robust Approach for Variability Extraction from the Linux Build System},
	Url = {http://doi.acm.org/10.1145/2362536.2362544},
	Year = {2012},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2362536.2362544},
	Bdsk-Url-2 = {https://doi.org/10.1145/2362536.2362544}}

@misc{undead,
	Date-Added = {2018-06-17 09:14:00 +0000},
	Date-Modified = {2018-06-17 09:14:08 +0000},
	Howpublished = {\url{https://github.com/KernelHaven/UnDeadAnalyzer}},
	Lastchecked = {Jun 17 2018},
	Note = {(Accessed on Jun 17 2018)},
	Title = {KernelHaven/UnDeadAnalyzer: Analyzer plug-in to detect (un-)dead code blocks},
	Bdsk-Url-1 = {https://github.com/KernelHaven/UnDeadAnalyzer}}

@article{Engstrm2011SoftwarePL,
	Author = {Emelie Engstr{\"o}m and Per Runeson},
	Date-Added = {2018-06-16 12:36:32 +0000},
	Date-Modified = {2018-06-16 12:36:32 +0000},
	Journal = {Information & Software Technology},
	Pages = {2-13},
	Title = {Software product line testing - A systematic mapping study},
	Volume = {53},
	Year = {2011}}

@inproceedings{Lee2012ASO,
	Author = {Jihyun Lee and Sungwon Kang and Danhyung Lee},
	Booktitle = {SPLC},
	Date-Added = {2018-06-16 12:29:10 +0000},
	Date-Modified = {2018-06-16 12:29:10 +0000},
	Title = {A survey on software product line testing},
	Year = {2012}}

@article{Thum:2014:CSA:2620784.2580950,
	Acmid = {2580950},
	Address = {New York, NY, USA},
	Articleno = {6},
	Author = {Th\"{u}m, Thomas and Apel, Sven and K\"{a}stner, Christian and Schaefer, Ina and Saake, Gunter},
	Date-Added = {2018-06-16 11:41:22 +0000},
	Date-Modified = {2018-06-16 11:41:22 +0000},
	Doi = {10.1145/2580950},
	Issn = {0360-0300},
	Issue_Date = {July 2014},
	Journal = {ACM Comput. Surv.},
	Keywords = {Product-line analysis, model checking, program family, software analysis, software product line, static analysis, theorem proving, type checking},
	Month = jun,
	Number = {1},
	Numpages = {45},
	Pages = {6:1--6:45},
	Publisher = {ACM},
	Title = {A Classification and Survey of Analysis Strategies for Software Product Lines},
	Url = {http://doi.acm.org/10.1145/2580950},
	Volume = {47},
	Year = {2014},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2580950},
	Bdsk-Url-2 = {https://doi.org/10.1145/2580950}}

@inproceedings{Chen:2005aa,
	Author = {K. Chen and H. Zhao and W. Zhang and H. Mei},
	Booktitle = {13th IEEE International Conference on Requirements Engineering (RE'05)(RE)},
	Date-Added = {2018-06-16 08:02:07 +0000},
	Date-Modified = {2018-06-16 08:02:09 +0000},
	Doi = {10.1109/RE.2005.9},
	Keywords = {null},
	Month = {08},
	Pages = {31-40},
	Title = {An Approach to Constructing Feature Models Based on Requirements Clustering},
	Url = {doi.ieeecomputersociety.org/10.1109/RE.2005.9},
	Volume = {00},
	Year = {2005},
	Bdsk-Url-1 = {doi.ieeecomputersociety.org/10.1109/RE.2005.9},
	Bdsk-Url-2 = {https://doi.org/10.1109/RE.2005.9}}

@misc{kconfig-language.txt,
	Date-Added = {2018-06-15 12:56:10 +0000},
	Date-Modified = {2018-06-15 12:56:18 +0000},
	Howpublished = {\url{https://github.com/torvalds/linux/blob/master/Documentation/kbuild/kconfig-language.txt}},
	Lastchecked = {Jun 15 2018},
	Note = {(Accessed on Jun 15 2018)},
	Title = {linux/kconfig-language.txt at master · torvalds/linux},
	Bdsk-Url-1 = {https://github.com/torvalds/linux/blob/master/Documentation/kbuild/kconfig-language.txt}}

@misc{makefiles.txt,
	Date-Added = {2018-06-15 12:54:13 +0000},
	Date-Modified = {2018-06-15 12:54:25 +0000},
	Howpublished = {\url{https://github.com/torvalds/linux/blob/master/Documentation/kbuild/makefiles.txt}},
	Lastchecked = {Jun 15 2018},
	Note = {(Accessed on Jun 15 2018)},
	Title = {linux/makefiles.txt at master · torvalds/linux},
	Bdsk-Url-1 = {https://github.com/torvalds/linux/blob/master/Documentation/kbuild/makefiles.txt}}

@book{Apel:2013:FSP:2541773,
	Author = {Apel, Sven and Batory, Don and K\"astner, Christian and Saake, Gunter},
	Date-Added = {2018-06-14 15:07:23 +0000},
	Date-Modified = {2018-06-24 18:38:13 +0000},
	Isbn = {3642375200, 9783642375200},
	Publisher = {Springer Publishing Company, Incorporated},
	Title = {Feature-Oriented Software Product Lines: Concepts and Implementation},
	Year = {2013}}

@misc{conditionals,
	Date-Added = {2018-06-14 14:00:34 +0000},
	Date-Modified = {2018-06-14 14:00:57 +0000},
	Howpublished = {\url{https://gcc.gnu.org/onlinedocs/cpp/Conditionals.html#Conditionals}},
	Lastchecked = {Jun 14 2018},
	Note = {(Accessed on Jun 14 2018)},
	Title = {The C Preprocessor: Conditionals},
	Bdsk-Url-1 = {https://gcc.gnu.org/onlinedocs/cpp/Conditionals.html#Conditionals}}

@article{mining-kbuild,
	Author = {Nadi, Sarah and Holt, Ric},
	Booktitle = {Proceedings of the Euromicro Conference on Software Maintenance and Reengineering, CSMR},
	Date-Added = {2018-06-14 13:30:39 +0000},
	Date-Modified = {2018-06-14 13:30:47 +0000},
	Month = {03},
	Pages = {107-116},
	Title = {Mining Kbuild to Detect Variability Anomalies in Linux},
	Year = {2012}}

@inproceedings{configuration-mismatches,
	Author = {El-Sharkawy, Sascha and Krafczyk, Adam and Schmid, Klaus},
	Date-Added = {2018-06-14 13:16:41 +0000},
	Date-Modified = {2018-06-14 13:17:16 +0000},
	Month = {09},
	Pages = {19-28},
	Title = {An Empirical Study of Configuration Mismatches in Linux},
	Year = {2017}}

@article{nadi-linux-kernel,
	Author = {Nadi, Sarah and Holt, Ric},
	Booktitle = {Journal of Software: Evolution and Process},
	Date-Added = {2018-06-14 12:32:57 +0000},
	Date-Modified = {2018-06-14 13:12:26 +0000},
	Month = {08},
	Title = {The Linux kernel: A case study of build system variability},
	Volume = {26},
	Year = {2014}}

@misc{intro-spl,
	Date-Added = {2018-06-13 15:31:28 +0000},
	Date-Modified = {2018-06-13 15:42:24 +0000},
	Howpublished = {\url{https://web.archive.org/web/20120213123740/http://www.softwareproductlines.com:80/introduction/introduction.html}},
	Lastchecked = {Jun 13 2018},
	Note = {(Accessed on Jun 13 2018)},
	Title = {Introduction to Software Product Lines},
	Bdsk-Url-1 = {https://web.archive.org/web/20120213123740/http://www.softwareproductlines.com:80/introduction/introduction.html}}

@book{spl-in-action,
	Author = {Linden, Frank and Schmid, Klaus and Rommes, Eelco},
	Date-Added = {2018-06-13 15:09:41 +0000},
	Date-Modified = {2018-06-13 15:12:07 +0000},
	Publisher = {Springer},
	Title = {Software Product Lines in Action},
	Year = {2007}}

@misc{RFC-bum,
	Date-Added = {2018-06-13 11:44:35 +0000},
	Date-Modified = {2018-06-13 11:44:35 +0000},
	Howpublished = {\url{https://tools.ietf.org/html/rfc2119}},
	Lastchecked = {Jun 13 2018},
	Note = {(Accessed on Jun 13 2018)},
	Title = {RFC 2119 - Key words for use in RFCs to Indicate Requirement Levels},
	Bdsk-Url-1 = {https://tools.ietf.org/html/rfc2119}}

@misc{ck-kbuild,
	Date-Added = {2018-06-10 14:17:16 +0000},
	Date-Modified = {2018-06-24 18:39:28 +0000},
	Howpublished = {\url{https://github.com/ckaestne/KBuildMiner}},
	Lastchecked = {Jun 10 2018},
	Note = {(Accessed on Jun 10 2018)},
	Title = {ckaestne/KBuildMiner},
	Bdsk-Url-1 = {https://github.com/ckaestne/KBuildMiner}}

@misc{ck-kconfig,
	Date-Added = {2018-06-10 14:15:51 +0000},
	Date-Modified = {2018-06-10 14:17:52 +0000},
	Howpublished = {\url{https://github.com/ckaestne/kconfigreader}},
	Lastchecked = {Jun 10 2018},
	Note = {(Accessed on Jun 10 2018)},
	Title = {ckaestne/kconfigreader: KConfigReader - accurate translation of kconfig files to propositional formulas},
	Bdsk-Url-1 = {https://github.com/ckaestne/kconfigreader}}

@misc{KernelHave-wh,
	Date-Added = {2018-06-10 14:10:43 +0000},
	Date-Modified = {2018-06-10 14:10:43 +0000},
	Howpublished = {\url{https://github.com/KernelHaven/KernelHaven/blob/master/README.md}},
	Lastchecked = {Jun 10 2018},
	Note = {(Accessed on Jun 10 2018)},
	Title = {KernelHaven/README.md at master · KernelHaven/KernelHaven},
	Bdsk-Url-1 = {https://github.com/KernelHaven/KernelHaven/blob/master/README.md}}

@misc{GNU-645,
	Date-Added = {2018-06-10 14:04:44 +0000},
	Date-Modified = {2018-06-10 14:04:44 +0000},
	Howpublished = {\url{https://www.gnu.org/licenses/gpl.html}},
	Lastchecked = {Jun 10 2018},
	Note = {(Accessed on Jun 10 2018)},
	Title = {GNU General Public License, Version 3 - GNU-Projekt - Free Software Foundation},
	Bdsk-Url-1 = {https://www.gnu.org/licenses/gpl.html}}

@misc{CodeBlockExtractor,
	Date-Added = {2018-06-10 13:57:02 +0000},
	Date-Modified = {2018-06-10 15:00:36 +0000},
	Howpublished = {\url{https://github.com/KernelHaven/CodeBlockExtractor}},
	Lastchecked = {Jun 10 2018},
	Note = {(Accessed on Jun 10 2018)},
	Title = {KernelHaven/CodeBlockExtractor},
	Bdsk-Url-1 = {https://github.com/KernelHaven/CodeBlockExtractor}}

@inproceedings{variabilitymodel-linux,
	Author = {Steven She and Rafael Lotufo and Thorsten Berger and Andrzej W ˛asowski and Krzysztof Czarnecki},
	Booktitle = {In VaMoS},
	Date-Added = {2018-06-07 15:40:45 +0000},
	Date-Modified = {2018-06-07 15:56:45 +0000},
	Title = {The variability model of the Linux kernel},
	Year = {2010}}

@inproceedings{KroeherEl-SharkawySchmid18,
	Author = {Christian Kr\"oher and Sascha El-Sharkawy and Klaus Schmid},
	Booktitle = {Proceedings of the 40th International Conference on Software Engineering},
	Date-Added = {2018-06-07 14:24:52 +0000},
	Date-Modified = {2018-06-07 18:20:15 +0000},
	Doi = {10.1145/3183440.3183480},
	Note = {accepted},
	Series = {ICSE '18},
	Title = {KernelHaven - An Experimentation Workbench for Analyzing Software Product Lines},
	Year = {2018},
	Bdsk-Url-1 = {https://doi.org/10.1145/3183440.3183480}}

@misc{ESXi-f0l,
	Date-Added = {2018-06-03 14:19:33 +0000},
	Date-Modified = {2018-06-03 14:19:33 +0000},
	Howpublished = {\url{https://www.vmware.com/products/esxi-and-esx.html}},
	Lastchecked = {Jun 03 2018},
	Note = {(Accessed on Jun 03 2018)},
	Title = {ESXi | Bare Metal Hypervisor | VMware},
	Bdsk-Url-1 = {https://www.vmware.com/products/esxi-and-esx.html}}

@misc{linux,
	Date-Added = {2018-06-03 14:10:01 +0000},
	Date-Modified = {2018-06-03 14:10:07 +0000},
	Howpublished = {\url{https://github.com/torvalds/linux}},
	Lastchecked = {Jun 03 2018},
	Note = {(Accessed on Jun 03 2018)},
	Title = {torvalds/linux: Linux kernel source tree},
	Bdsk-Url-1 = {https://github.com/torvalds/linux}}

@misc{ComAn-tool,
	Date-Added = {2018-05-25 09:43:23 +0000},
	Date-Modified = {2018-05-25 09:43:30 +0000},
	Howpublished = {\url{https://github.com/KernelHaven/ComAn}},
	Lastchecked = {May 25 2018},
	Note = {(Accessed on May 25 2018)},
	Title = {KernelHaven/ComAn: Variability Analysis Tool for Commits}}

@inproceedings{Tartler:2011:FCC:1966445.1966451,
	Abstract = {Much system software can be configured at compile time to tailor it with respect to a broad range of supported hardware architectures and application domains. A good example is the Linux kernel, which provides more than 10,000 configurable features, growing rapidly.
From the maintenance point of view, compile-time configurability imposes big challenges. The configuration model (the selectable features and their constraints as presented to the user) and the configurability that is actually implemented in the code have to be kept in sync, which, if performed manually, is a tedious and error-prone task. In the case of Linux, this has led to numerous defects in the source code, many of which are actual bugs.
We suggest an approach to automatically check for configurability-related implementation defects in large-scale configurable system software. The configurability is extracted from its various implementation sources and examined for inconsistencies, which manifest in seemingly conditional code that is in fact unconditional. We evaluate our approach with the latest version of Linux, for which our tool detects 1,776 configurability defects, which manifest as dead/superfluous source code and bugs. Our findings have led to numerous source-code improvements and bug fixes in Linux: 123 patches (49 merged) fix 364 defects, 147 of which have been confirmed by the corresponding Linux developers and 20 as fixing a new bug.},
	Acmid = {1966451},
	Address = {New York, NY, USA},
	Author = {Tartler, Reinhard and Lohmann, Daniel and Sincero, Julio and Schr\"{o}der-Preikschat, Wolfgang},
	Booktitle = {Proceedings of the Sixth Conference on Computer Systems},
	Date-Added = {2018-02-06 10:38:21 +0000},
	Date-Modified = {2018-02-06 10:40:15 +0000},
	Doi = {10.1145/1966445.1966451},
	Isbn = {978-1-4503-0634-8},
	Keywords = {configurability, linux, maintenance, static analysis, vamos, undertaker},
	Location = {Salzburg, Austria},
	Numpages = {14},
	Pages = {47--60},
	Publisher = {ACM},
	Series = {EuroSys '11},
	Title = {Feature Consistency in Compile-time-configurable System Software: Facing the Linux 10,000 Feature Problem},
	Url = {http://doi.acm.org/10.1145/1966445.1966451},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QdS4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxMS1VbmRlcnRha2VyLnBkZtIXCxgZV05TLmRhdGFPEQHwAAAAAAHwAAIAAAdjcnVjaWFsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8TMjAxMS1VbmRlcnRha2VyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAADAAgAAAogY3UAAAAAAAAAAAAAAAAAB3NvdXJjZXMAAAIAey86VXNlcnM6bW9yaXR6OlJlc2lsaW8gU3luYzpQcml2YXQ6RGF0ZWlzcGVpY2hlcjpTY2h1bGUgdW5kIFN0dWRpdW06SW5mb3JtYXRpay1TdHVkaXVtOlNTRS1IaXdpOnNvdXJjZXM6MjAxMS1VbmRlcnRha2VyLnBkZgAADgAoABMAMgAwADEAMQAtAFUAbgBkAGUAcgB0AGEAawBlAHIALgBwAGQAZgAPABAABwBjAHIAdQBjAGkAYQBsABIAeVVzZXJzL21vcml0ei9SZXNpbGlvIFN5bmMvUHJpdmF0L0RhdGVpc3BlaWNoZXIvU2NodWxlIHVuZCBTdHVkaXVtL0luZm9ybWF0aWstU3R1ZGl1bS9TU0UtSGl3aS9zb3VyY2VzLzIwMTEtVW5kZXJ0YWtlci5wZGYAABMAAS8AABUAAgAN//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4BBgELARMDBwMJAw4DGQMiAzADNAM7A0QDSQNWA1kDawNuA3MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADdQ==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1966445.1966451},
	Bdsk-Url-2 = {https://dx.doi.org/10.1145/1966445.1966451},
	Bdsk-Url-3 = {https://github.com/torvalds/linux}}

@inproceedings{Kenner:2010:TTT:1868688.1868693,
	Abstract = {Software product lines have gained momentum as an approach to generate many variants of a program, each tailored to a specific use case, from a common code base. However, the implementation of product lines raises new challenges, as potentially millions of program variants are developed in parallel. In prior work, we and others have developed product-line-aware type systems to detect type errors in a product line, without generating all variants. With TypeChef, we build a similar type checker for product lines written in C that implements variability with \#ifdef directives of the C preprocessor. However, a product-line-aware type system for C is more difficult than expected due to several peculiarities of the preprocessor, including lexical macros and unrestricted use of \#ifdef directives. In this paper, we describe the problems faced and our progress to solve them with TypeChef. Although TypeChef is still under development and cannot yet process arbitrary C code, we demonstrate its capabilities so far with a case study: By type checking the open-source web server Boa with potentially 2110 variants, we found type errors in several variants.},
	Acmid = {1868693},
	Address = {New York, NY, USA},
	Author = {Kenner, Andy and K\"{a}stner, Christian and Haase, Steffen and Leich, Thomas},
	Booktitle = {Proceedings of the 2Nd International Workshop on Feature-Oriented Software Development},
	Date-Added = {2018-02-06 10:33:47 +0000},
	Date-Modified = {2018-06-10 14:59:35 +0000},
	Doi = {10.1145/1868688.1868693},
	Isbn = {978-1-4503-0208-1},
	Keywords = {\#ifdef, C, conditional compilation, cpp, disciplined annotations, partial preprocessor, type system},
	Location = {Eindhoven, The Netherlands},
	Numpages = {8},
	Pages = {25--32},
	Publisher = {ACM},
	Series = {FOSD '10},
	Title = {TypeChef: Toward Type Checking \#Ifdef Variability in C},
	Url = {http://doi.acm.org/10.1145/1868688.1868693},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8Qcy4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxMC1UeXBlQ2hlZi5wZGbSFwsYGVdOUy5kYXRhTxEB6AAAAAAB6AACAAAHY3J1Y2lhbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////ETIwMTAtVHlwZUNoZWYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAwAIAAAKIGN1AAAAAAAAAAAAAAAAAAdzb3VyY2VzAAACAHkvOlVzZXJzOm1vcml0ejpSZXNpbGlvIFN5bmM6UHJpdmF0OkRhdGVpc3BlaWNoZXI6U2NodWxlIHVuZCBTdHVkaXVtOkluZm9ybWF0aWstU3R1ZGl1bTpTU0UtSGl3aTpzb3VyY2VzOjIwMTAtVHlwZUNoZWYucGRmAAAOACQAEQAyADAAMQAwAC0AVAB5AHAAZQBDAGgAZQBmAC4AcABkAGYADwAQAAcAYwByAHUAYwBpAGEAbAASAHdVc2Vycy9tb3JpdHovUmVzaWxpbyBTeW5jL1ByaXZhdC9EYXRlaXNwZWljaGVyL1NjaHVsZSB1bmQgU3R1ZGl1bS9JbmZvcm1hdGlrLVN0dWRpdW0vU1NFLUhpd2kvc291cmNlcy8yMDEwLVR5cGVDaGVmLnBkZgAAEwABLwAAFQACAA3//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgEEAQkBEQL9Av8DBAMPAxgDJgMqAzEDOgM/A0wDTwNhA2QDaQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1868688.1868693},
	Bdsk-Url-2 = {https://dx.doi.org/10.1145/1868688.1868693}}

@misc{SAT-4nb,
	Date-Added = {2018-02-06 09:28:42 +0000},
	Date-Modified = {2018-02-06 09:28:57 +0000},
	Howpublished = {\url{https://baldur.iti.kit.edu/sat-competition-2017/}},
	Lastchecked = {Feb 06 2018},
	Note = {(Accessed on Feb 06 2018)},
	Title = {SAT Competition 2017},
	Year = {2017}}

@techreport{ComAn,
	Abstract = {Software Product Line (SPL) evolution affects a variety of artifact types, each containing their artifact-specific information as well as variability information. While the former information type defines the basic content of an artifact, like the general program definition in code artifacts, the latter supports the customization of these artifacts for different products of the SPL. Existing work that aims at characterizing the state and evolution of a product line identifies general SPL evolution scenarios or evaluates the (co-)evolution of variability information in different types of artifacts. However, these results are typically based on a feature perspective, which abstracts from the SPL evolution at large. We argue that an artifact-based analysis of product line evolution will complement existing work by analyzing the intensity of changes to different artifact and information types. In this report, we therefore present an approach for and the results of the extraction and analysis of changes introduced to artifact-specific and variability information in code, build and variability model artifacts. This approach has been developed for and applied to the Linux kernel. In order to broaden our analysis, we also apply the approach to the Coreboot firmware. The results reveal the intensity of changes over the evolution history of both SPLs. Further, we compare the intensity of changes across both SPLs with respect to the size of the changes as well as over time.},
	Author = {Christian Kr{\"o}her and Klaus Schmid},
	Date-Added = {2018-02-06 08:44:03 +0000},
	Date-Modified = {2018-05-25 09:41:27 +0000},
	Institution = {Software Systems Engineering, Institut f{\"u}r Informatik, Universit{\"a}t Hildesheim},
	Number = {2/2017, SSE 2/17/E},
	Organization = {University of Hildesheim},
	Pages = {1-57},
	Title = {A Commit-Based Analysis of Software Product Line Evolution: Two Case Studies},
	Url = {https://sse.uni-hildesheim.de/media/fb4/informatik/AG_SSE/PDFs/publications/SPL-Evolution/TR-Evolution.pdf},
	Year = {2017},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8Qdy4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxNy1UUi1Fdm9sdXRpb24ucGRm0hcLGBlXTlMuZGF0YU8RAfgAAAAAAfgAAgAAB2NydWNpYWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////xUyMDE3LVRSLUV2b2x1dGlvbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAMACAAACiBjdQAAAAAAAAAAAAAAAAAHc291cmNlcwAAAgB9LzpVc2Vyczptb3JpdHo6UmVzaWxpbyBTeW5jOlByaXZhdDpEYXRlaXNwZWljaGVyOlNjaHVsZSB1bmQgU3R1ZGl1bTpJbmZvcm1hdGlrLVN0dWRpdW06U1NFLUhpd2k6c291cmNlczoyMDE3LVRSLUV2b2x1dGlvbi5wZGYAAA4ALAAVADIAMAAxADcALQBUAFIALQBFAHYAbwBsAHUAdABpAG8AbgAuAHAAZABmAA8AEAAHAGMAcgB1AGMAaQBhAGwAEgB7VXNlcnMvbW9yaXR6L1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxNy1UUi1Fdm9sdXRpb24ucGRmAAATAAEvAAAVAAIADf//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAQgBDQEVAxEDEwMYAyMDLAM6Az4DRQNOA1MDYANjA3UDeAN9AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA38=},
	Bdsk-Url-1 = {https://sse.uni-hildesheim.de/media/fb4/informatik/AG_SSE/PDFs/publications/SPL-Evolution/TR-Evolution.pdf}}

@inproceedings{EichelbergerSchmid12,
	Abstract = {Die Erfassung von Produktmetriken zur Laufzeit ist ein wesentlicher Baustein einer Qualit{\"a}tsstrategie in der Produktentwicklung. Die Erfassung von Produktmetriken in der Entwicklung ist jedoch oft mit signifikantem Aufwand verbunden, da viele Werkzeuge nur bestimmte Eigenschaften erfassen k{\"o}nnen und ihre Verwendung oft sehr komplex ist. Dar{\"u}ber hinaus entsteht durch die Durchf{\"u}hrung der Messung meist ein signifikanter Laufzeit-Overhead. Das Ziel des SPASS-meter-Werkzeugs ist die integrierte Erfassung einer Vielzahl von Metriken bei einfacher Konfiguration und geringem Laufzeit-Overhead. In diesem Beitrag stellen wir SPASS-meter vor und vergleichen es mit bekannten {\"a}hnlichen Werkzeugen wie Kieker, OpenCore, Xprof und HPROF. Eine {\"U}bersicht der St{\"a}rken und Schw{\"a}chen schlie{\ss}t den Vergleich ab.},
	Booktitle = {Proceedings of the DASMA Metrik Kongress (MetriKon '12)},
	Date-Added = {2018-02-06 08:06:48 +0000},
	Date-Modified = {2018-02-06 08:06:48 +0000},
	Editor = {G. B{\"u}ren and R. R. Dumke and C. Ebert and H. M{\"u}nch},
	Pages = {171-180},
	Publisher = {- Shaker Verlag},
	Title = {Erhebung von Produkt-Laufzeit-Metriken: Ein Vergleich mit dem SPASS-Meter-Werkzeug},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8Qdi4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxMi1TcGFzcy1NZXRlci5wZGbSFwsYGVdOUy5kYXRhTxEB8gAAAAAB8gACAAAHY3J1Y2lhbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////FDIwMTItU3Bhc3MtTWV0ZXIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAwAIAAAKIGN1AAAAAAAAAAAAAAAAAAdzb3VyY2VzAAACAHwvOlVzZXJzOm1vcml0ejpSZXNpbGlvIFN5bmM6UHJpdmF0OkRhdGVpc3BlaWNoZXI6U2NodWxlIHVuZCBTdHVkaXVtOkluZm9ybWF0aWstU3R1ZGl1bTpTU0UtSGl3aTpzb3VyY2VzOjIwMTItU3Bhc3MtTWV0ZXIucGRmAA4AKgAUADIAMAAxADIALQBTAHAAYQBzAHMALQBNAGUAdABlAHIALgBwAGQAZgAPABAABwBjAHIAdQBjAGkAYQBsABIAelVzZXJzL21vcml0ei9SZXNpbGlvIFN5bmMvUHJpdmF0L0RhdGVpc3BlaWNoZXIvU2NodWxlIHVuZCBTdHVkaXVtL0luZm9ybWF0aWstU3R1ZGl1bS9TU0UtSGl3aS9zb3VyY2VzLzIwMTItU3Bhc3MtTWV0ZXIucGRmABMAAS8AABUAAgAN//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4BBwEMARQDCgMMAxEDHAMlAzMDNwM+A0cDTANZA1wDbgNxA3YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==}}

@misc{KernelHaven,
	Date-Added = {2018-02-06 08:00:34 +0000},
	Date-Modified = {2018-02-06 08:01:00 +0000},
	Howpublished = {\url{https://github.com/KernelHaven/KernelHaven}},
	Lastchecked = {Feb 06 2018},
	Note = {(Accessed on Feb 06 2018)},
	Title = {KernelHaven github-repo},
	Bdsk-Url-1 = {https://github.com/KernelHaven/KernelHaven}}

@article{Debray:2000:CTC:349214.349233,
	Abstract = {In recent years there has been an increasing trend toward the incorpor ation of computers into a variety of devices where the amount of memory available is limited. This makes it desirable to try to reduce the size of applications where possible. This article explores the use of compiler techniques to accomplish code compaction to yield smaller executables. The main contribution of this article is to show that careful, aggressive, interprocedural optimization, together with procedural abstraction of repeated code fragments, can yield significantly better reductions in code size than previous approaches, which have generally focused on abstraction of repeated instruction sequences. We also show how ``equivalent'' code fragments can be detected and factored out using conventional compiler techniques, and without having to resort to purely linear treatments of code sequences as in suffix-tree-based approaches, thereby setting up a framework for code compaction that can be more flexible in its treatment of what code fragments are considered equivalent. Our ideas have been implemented in the form of a binary-rewriting tool that reduces the size of executables by about 30% on the average.},
	Acmid = {349233},
	Address = {New York, NY, USA},
	Author = {Debray, Saumya K. and Evans, William and Muth, Robert and De Sutter, Bjorn},
	Date-Added = {2018-02-06 07:54:30 +0000},
	Date-Modified = {2018-02-06 11:05:20 +0000},
	Doi = {10.1145/349214.349233},
	Issn = {0164-0925},
	Issue_Date = {March 2000},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {code compaction, code compression, code size reduction, dead code},
	Month = mar,
	Number = {2},
	Numpages = {38},
	Pages = {378--415},
	Publisher = {ACM},
	Title = {Compiler Techniques for Code Compaction},
	Url = {http://doi.acm.org/10.1145/349214.349233},
	Volume = {22},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8Qki4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAwMC1Db21waWxlci1UZWNobmlxdWVzLWZvci1Db2RlLUNvbXBsZXRpb24ucGRm0hcLGBlXTlMuZGF0YU8RAmIAAAAAAmIAAgAAB2NydWNpYWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x8yMDAwLUNvbXBpbGVyLVRlY2gjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAMACAAACiBjdQAAAAAAAAAAAAAAAAAHc291cmNlcwAAAgCYLzpVc2Vyczptb3JpdHo6UmVzaWxpbyBTeW5jOlByaXZhdDpEYXRlaXNwZWljaGVyOlNjaHVsZSB1bmQgU3R1ZGl1bTpJbmZvcm1hdGlrLVN0dWRpdW06U1NFLUhpd2k6c291cmNlczoyMDAwLUNvbXBpbGVyLVRlY2huaXF1ZXMtZm9yLUNvZGUtQ29tcGxldGlvbi5wZGYADgBiADAAMgAwADAAMAAtAEMAbwBtAHAAaQBsAGUAcgAtAFQAZQBjAGgAbgBpAHEAdQBlAHMALQBmAG8AcgAtAEMAbwBkAGUALQBDAG8AbQBwAGwAZQB0AGkAbwBuAC4AcABkAGYADwAQAAcAYwByAHUAYwBpAGEAbAASAJZVc2Vycy9tb3JpdHovUmVzaWxpbyBTeW5jL1ByaXZhdC9EYXRlaXNwZWljaGVyL1NjaHVsZSB1bmQgU3R1ZGl1bS9JbmZvcm1hdGlrLVN0dWRpdW0vU1NFLUhpd2kvc291cmNlcy8yMDAwLUNvbXBpbGVyLVRlY2huaXF1ZXMtZm9yLUNvZGUtQ29tcGxldGlvbi5wZGYAEwABLwAAFQACAA3//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgEjASgBMAOWA5gDnQOoA7EDvwPDA8oD0wPYA+UD6AP6A/0EAgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAQE},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/349214.349233},
	Bdsk-Url-2 = {https://dx.doi.org/10.1145/349214.349233}}

@article{10.1109/MS.2013.83,
	Abstract = {Product line engineering (PLE) is one of the few industry-ready methods to manage reuse and variability in a defined way and thus bring software development maturity to a more advanced stage. The goal is to deliver specific product variants with fast cycle times at a manageable life-cycle cost with a defined quality level. Many IT and software organizations have started PLE but fail in industrializing the concepts and thus do not achieve sustainable benefits. Authors Klaus Schmid and Eduardo Santana de Almeida look at current technology for modeling and managing variation and thus facilitate PLE. The Web extra at http://youtu.be/R1gybFwAy10 is a video interview with David Weiss discussing the benefits of using software product line engineering to produce software families.},
	Address = {Los Alamitos, CA, USA},
	Author = {Eduardo Santana de Almeida, and Klaus Schmid,},
	Date-Added = {2017-11-28 13:12:48 +0000},
	Date-Modified = {2017-11-28 13:13:42 +0000},
	Doi = {doi.ieeecomputersociety.org/10.1109/MS.2013.83},
	Issn = {0740-7459},
	Journal = {IEEE Software},
	Pages = {24-30},
	Publisher = {IEEE Computer Society},
	Title = {Product Line Engineering},
	Volume = {30},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QgS4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxMy1Qcm9kdWN0TGluZUVuZ2luZWVyaW5nLnBkZtIXCxgZV05TLmRhdGFPEQIgAAAAAAIgAAIAAAdjcnVjaWFsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fMjAxMy1Qcm9kdWN0TGluZUVuZ2luZWVyaW5nLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAADAAgAAAogY3UAAAAAAAAAAAAAAAAAB3NvdXJjZXMAAAIAhy86VXNlcnM6bW9yaXR6OlJlc2lsaW8gU3luYzpQcml2YXQ6RGF0ZWlzcGVpY2hlcjpTY2h1bGUgdW5kIFN0dWRpdW06SW5mb3JtYXRpay1TdHVkaXVtOlNTRS1IaXdpOnNvdXJjZXM6MjAxMy1Qcm9kdWN0TGluZUVuZ2luZWVyaW5nLnBkZgAADgBAAB8AMgAwADEAMwAtAFAAcgBvAGQAdQBjAHQATABpAG4AZQBFAG4AZwBpAG4AZQBlAHIAaQBuAGcALgBwAGQAZgAPABAABwBjAHIAdQBjAGkAYQBsABIAhVVzZXJzL21vcml0ei9SZXNpbGlvIFN5bmMvUHJpdmF0L0RhdGVpc3BlaWNoZXIvU2NodWxlIHVuZCBTdHVkaXVtL0luZm9ybWF0aWstU3R1ZGl1bS9TU0UtSGl3aS9zb3VyY2VzLzIwMTMtUHJvZHVjdExpbmVFbmdpbmVlcmluZy5wZGYAABMAAS8AABUAAgAN//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4BEgEXAR8DQwNFA0oDVQNeA2wDcAN3A4ADhQOSA5UDpwOqA68AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADsQ==},
	Bdsk-Url-1 = {https://dx.doi.org/10.1109/MS.2013.83}}

@article{Dintzner2017,
	Abstract = {The evolution of highly configurable systems is known to be a challenging task. Thorough understanding of configuration options their relationships, and their implementation in various types of artefacts (variability model, mapping, and implementation) is required to avoid compilation errors, invalid products, or dead code. Recent studies focusing on co-evolution of artefacts detailed feature-oriented change scenarios, describing how related artefacts might change over time. However, relying on manual analysis of commits, such work do not provide the means to obtain quantitative information on the frequency of described scenarios nor information on the exhaustiveness of the presented scenarios for the evolution of a large scale system. In this work, we propose FEVER and its instantiation for the Linux kernel. FEVER extracts detailed information on changes in variability models (KConfig files), assets (preprocessor based C code), and mappings (Makefiles). We apply this methodology to the Linux kernel and build a dataset comprised of 15 releases of the kernel history. We performed an evaluation of the FEVER approach by manually inspecting the data and compared it with commits in the system's history. The evaluation shows that FEVER accurately captures feature related changes for more than 85{\%} of the 810 manually inspected commits. We use the collected data to reflect on occurrences of co-evolution in practice. Our analysis shows that complex co-evolution scenarios occur in every studied release but are not among the most frequent change scenarios, as they only occur for 8 to 13{\%} of the evolving features. Moreover, only a minority of developers working on a given release will make changes to all artefacts related to a feature (between 10{\%} and 13{\%} of authors). While our conclusions are derived from observations on the evolution of the Linux kernel, we believe that they may have implications for tool developers as well as guide further research in the field of co-evolution of artefacts.},
	Author = {Dintzner, Nicolas and van Deursen, Arie and Pinzger, Martin},
	Date-Added = {2017-11-28 13:11:06 +0000},
	Date-Modified = {2017-11-28 13:11:06 +0000},
	Day = {04},
	Doi = {10.1007/s10664-017-9557-6},
	Issn = {1573-7616},
	Journal = {Empirical Software Engineering},
	Month = {Nov},
	Title = {FEVER: An approach to analyze feature-oriented changes and artefact co-evolution in highly configurable systems},
	Url = {https://doi.org/10.1007/s10664-017-9557-6},
	Year = {2017},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QcC4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxMy1GRVZFUi5wZGbSFwsYGVdOUy5kYXRhTxEB2gAAAAAB2gACAAAHY3J1Y2lhbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////DjIwMTMtRkVWRVIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAwAIAAAKIGN1AAAAAAAAAAAAAAAAAAdzb3VyY2VzAAACAHYvOlVzZXJzOm1vcml0ejpSZXNpbGlvIFN5bmM6UHJpdmF0OkRhdGVpc3BlaWNoZXI6U2NodWxlIHVuZCBTdHVkaXVtOkluZm9ybWF0aWstU3R1ZGl1bTpTU0UtSGl3aTpzb3VyY2VzOjIwMTMtRkVWRVIucGRmAA4AHgAOADIAMAAxADMALQBGAEUAVgBFAFIALgBwAGQAZgAPABAABwBjAHIAdQBjAGkAYQBsABIAdFVzZXJzL21vcml0ei9SZXNpbGlvIFN5bmMvUHJpdmF0L0RhdGVpc3BlaWNoZXIvU2NodWxlIHVuZCBTdHVkaXVtL0luZm9ybWF0aWstU3R1ZGl1bS9TU0UtSGl3aS9zb3VyY2VzLzIwMTMtRkVWRVIucGRmABMAAS8AABUAAgAN//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4BAQEGAQ4C7ALuAvMC/gMHAxUDGQMgAykDLgM7Az4DUANTA1gAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADWg==},
	Bdsk-Url-1 = {https://doi.org/10.1007/s10664-017-9557-6}}

@inproceedings{Al-Hajjaji:2016:IEP:2993236.2993253,
	Abstract = {A software product line comprises a family of software products that share a common set of features. It enables customers to compose software systems from a managed set of features. Testing every product of a product line individually is often infeasible due to the exponential number of possible products in the number of features. Several approaches have been proposed to restrict the number of products to be tested by sampling a subset of products achieving sufficient combinatorial interaction coverage. However, existing sampling algorithms do not scale well to large product lines, as they require a considerable amount of time to generate the samples. Moreover, samples are not available until a sampling algorithm completely terminates. As testing time is usually limited, we propose an incremental approach of product sampling for pairwise interaction testing (called IncLing), which enables developers to generate samples on demand in a step-wise manner. Furthermore, IncLing uses heuristics to efficiently achieve pairwise interaction coverage with a reasonable number of products. We evaluated IncLing by comparing it against existing sampling algorithms using feature models of different sizes. The results of our approach indicate efficiency improvements for product-line testing.},
	Acmid = {2993253},
	Address = {New York, NY, USA},
	Author = {Al-Hajjaji, Mustafa and Krieter, Sebastian and Th\"{u}m, Thomas and Lochau, Malte and Saake, Gunter},
	Booktitle = {Proceedings of the 2016 ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences},
	Date-Added = {2017-11-28 13:06:49 +0000},
	Date-Modified = {2017-11-28 13:07:49 +0000},
	Doi = {10.1145/2993236.2993253},
	Isbn = {978-1-4503-4446-3},
	Keywords = {Software product lines, combinatorial interaction testing, model-based testing, sampling},
	Location = {Amsterdam, Netherlands},
	Numpages = {12},
	Pages = {144--155},
	Publisher = {ACM},
	Series = {GPCE 2016},
	Title = {IncLing: Efficient Product-line Testing Using Incremental Pairwise Sampling},
	Url = {http://doi.acm.org/10.1145/2993236.2993253},
	Year = {2016},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8Qci4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxNi1JbmNMaW5nLnBkZtIXCxgZV05TLmRhdGFPEQHiAAAAAAHiAAIAAAdjcnVjaWFsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8QMjAxNi1JbmNMaW5nLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAADAAgAAAogY3UAAAAAAAAAAAAAAAAAB3NvdXJjZXMAAAIAeC86VXNlcnM6bW9yaXR6OlJlc2lsaW8gU3luYzpQcml2YXQ6RGF0ZWlzcGVpY2hlcjpTY2h1bGUgdW5kIFN0dWRpdW06SW5mb3JtYXRpay1TdHVkaXVtOlNTRS1IaXdpOnNvdXJjZXM6MjAxNi1JbmNMaW5nLnBkZgAOACIAEAAyADAAMQA2AC0ASQBuAGMATABpAG4AZwAuAHAAZABmAA8AEAAHAGMAcgB1AGMAaQBhAGwAEgB2VXNlcnMvbW9yaXR6L1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxNi1JbmNMaW5nLnBkZgATAAEvAAAVAAIADf//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAQMBCAEQAvYC+AL9AwgDEQMfAyMDKgMzAzgDRQNIA1oDXQNiAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA2Q=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2993236.2993253},
	Bdsk-Url-2 = {https://dx.doi.org/10.1145/2993236.2993253}}

@inbook{Wieringa2013,
	Abstract = {Solvers for propositional logic formulas, so called SAT solvers, are used in many practical applications. As multi-core and multi-processor hardware has become widely available, parallelizations of such solvers are actively researched. Such research typically ignores the incremental problem specification feature that modern SAT solvers possess. This feature is, however, crucial for many of the real-life applications of SAT solvers. Such applications include formal verification, equivalence checking, and typical artificial intelligence tasks such as scheduling, planning and reasoning.},
	Address = {Berlin, Heidelberg},
	Author = {Wieringa, Siert and Heljanko, Keijo},
	Booktitle = {Tools and Algorithms for the Construction and Analysis of Systems: 19th International Conference, TACAS 2013, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2013, Rome, Italy, March 16-24, 2013. Proceedings},
	Date-Added = {2017-11-28 12:59:01 +0000},
	Date-Modified = {2017-11-28 12:59:01 +0000},
	Doi = {10.1007/978-3-642-36742-7_10},
	Editor = {Piterman, Nir and Smolka, Scott A.},
	Isbn = {978-3-642-36742-7},
	Pages = {139--153},
	Publisher = {Springer Berlin Heidelberg},
	Title = {Asynchronous Multi-core Incremental SAT Solving},
	Url = {https://doi.org/10.1007/978-3-642-36742-7_10},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8Qmi4uLy4uLy4uL1Jlc2lsaW8gU3luYy9Qcml2YXQvRGF0ZWlzcGVpY2hlci9TY2h1bGUgdW5kIFN0dWRpdW0vSW5mb3JtYXRpay1TdHVkaXVtL1NTRS1IaXdpL3NvdXJjZXMvMjAxMy1Bc3luY2hyb25vdXMtTXVsdGktQ29yZS1JbmNyZW1lbnRhbCBTQVQtU29sdmluZy5wZGbSFwsYGVdOUy5kYXRhTxECggAAAAACggACAAAHY3J1Y2lhbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////HzIwMTMtQXN5bmNocm9ub3VzLSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAwAIAAAKIGN1AAAAAAAAAAAAAAAAAAdzb3VyY2VzAAACAKAvOlVzZXJzOm1vcml0ejpSZXNpbGlvIFN5bmM6UHJpdmF0OkRhdGVpc3BlaWNoZXI6U2NodWxlIHVuZCBTdHVkaXVtOkluZm9ybWF0aWstU3R1ZGl1bTpTU0UtSGl3aTpzb3VyY2VzOjIwMTMtQXN5bmNocm9ub3VzLU11bHRpLUNvcmUtSW5jcmVtZW50YWwgU0FULVNvbHZpbmcucGRmAA4AcgA4ADIAMAAxADMALQBBAHMAeQBuAGMAaAByAG8AbgBvAHUAcwAtAE0AdQBsAHQAaQAtAEMAbwByAGUALQBJAG4AYwByAGUAbQBlAG4AdABhAGwAIABTAEEAVAAtAFMAbwBsAHYAaQBuAGcALgBwAGQAZgAPABAABwBjAHIAdQBjAGkAYQBsABIAnlVzZXJzL21vcml0ei9SZXNpbGlvIFN5bmMvUHJpdmF0L0RhdGVpc3BlaWNoZXIvU2NodWxlIHVuZCBTdHVkaXVtL0luZm9ybWF0aWstU3R1ZGl1bS9TU0UtSGl3aS9zb3VyY2VzLzIwMTMtQXN5bmNocm9ub3VzLU11bHRpLUNvcmUtSW5jcmVtZW50YWwgU0FULVNvbHZpbmcucGRmABMAAS8AABUAAgAN//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4BKwEwATgDvgPAA8UD0APZA+cD6wPyA/sEAAQNBBAEIgQlBCoAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAELA==},
	Bdsk-Url-1 = {https://doi.org/10.1007/978-3-642-36742-7_10}}
